---
title: "Tutorial 2-Introduction to R"
author: "Maria Anastasiadi"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data Types in R

The data stored in R can belong to different types and structures. Below is a list with the main data types (or *objects*) R can handle: <br>

-   Numeric (real numbers)
-   Integer
-   Complex
-   Character
-   Logical (`TRUE` / `FALSE`)
-   Dates

Numbers in R are generally treated as numeric objects (i.e. double precision real numbers). This means that even if you see a number like "1" or "2" in R, which you might think of as integers, they are likely represented behind the scenes as numeric objects (so something like "1.00" or "2.00").\
<br> If you explicitly want an integer, you need to specify the `L` suffix. So entering `1` in R gives you a numeric object; entering `1L` explicitly gives you an integer object. <br> <br> There is also a special number `Inf` which represents infinity. <br> <br> Finally, the value `NaN` represents an undefined value ("not a number")\
<br>

For example:

```{r}
0/0
```

The value `NaN` can also represent a missing value.

**Character Strings:** Character strings or (*strings* for short) typically consist of strings of letters but also can contain numbers and symbols. To create a character string we must contain it within `" "` or `' '`.

Example1:

```{r}
String1 <-"Hello World"
```

Example2:

```{r}
String2 <- "1234"
```

We can check if `String2` is a number as follows:

```{r}
# Check the type of String2
is.integer(String2)
```

**Dates:** Attributed to dates and time types of data. <br> An easy way to convert strings to dates is by installing and using the package **lubridate**

Example:

```{r}
# install/load lubridate 
pacman::p_load(lubridate)
```

Then create a date using the `ymd()` function

```{r}
# read date in year-month-day format
ymd("2020-10-11")
```

<br><br>

## Data Structures in R

<br>

![](Pictures%20for%20RMarkdown%20Docs/r-programming-data-structures.png){fig-align="right" width="70%"}

<br>

### Vectors

Vectors is a basic data structure that plays an important role in R. It is defined as an ordered set of values called *elements* or *components*. A vector can contain any number of elements, but all of the elements must be of the same type of values (e.g. integer, double, character, logical). These Vectors are called **Atomic Vectors**.

**Numeric Vectors:** Integer and double vectors are collectively known as *numeric vectors*.

**Creating vectors**

In R, we can create vectors with the `c()` function.

Example1:

```{r}
# Create a vector of integers
v1 <- c(1:10)

# Print the vector v1 in the console
v1
```

Check the type of the vector with the `typeof()` function:

```{r}
typeof(v1)
```

Check the length of the vector (number of elements) with the `length()` function:

```{r}
length(v1)
```

Check the class of the vector with the `class()` function:

```{r}
class(v1)
```

<br>

Example2:

```{r}
# Create a numeric vector
v2 <- c(4, 6, 7, 9, 1)
```

Check the type of the vector with the `typeof()` function:

```{r}
typeof(v2)
```

Check class of vector v2 with the 'class()' function

```{r}
class(v2)
```

**Note:** If we wanted vector v2 to be of type "integer" we had to specify it as below: <br>

```{r}
v2.int <- c(4L, 6L, 7L, 9L, 1L)
typeof(v2.int)
class(v2.int)
```

<br>

There are various other ways to create a vector in R, which are as follows:

1.  Using the colon `(:)` operator:

```{r}
v1 <- 1:10
```

2.  Using the `seq()` function:

```{r}
v1 <- seq(from=1, to=10, by=1)

# Or simply

v1 <- seq(1, 10, 1)
```

3.  Using the `rep()` function

```{r}
v3 <- rep(3, times=5)

# Print v3
v3
```

We can also use the `rep()` function to replicate another vector as many times we want:

```{r}
v4<-rep(v3, times=2)

# Print v4
v4
```

Or each element of a vector as many times we want:

```{r}
v5 <- rep(v3, each=2)

# Print v5
v5
```

You can also combine repeating elements and the whole vector in the same operation

```{r}
rep(1:3,each=2, times = 3)

```

As you probably noticed already, the difference is that with the`c()` function we can create any vector we like while with the other methods we have certain constraints. <br> We can also use the `c()` function to concatenate vectors of the same type:

```{r}
v12 <- c(v1, v2)

# Print v5
v12
```

### Naming Vector Elements

When creating a vector we can at the same time assign a name at each element within the vector. For example:

```{r}
new.vector <- c(a=3, b=8, c=1)

# Print new.vector
new.vector
```

To see the names of a vector we can use the `names()` function as follows:

```{r}
names(new.vector)
```

We can also use the `names()` function to assign names to the elements of a vector after having being created. <br> For example:

```{r}
names(v3) <- rep("three", 5)

# Print vector in the console:
v3
```

You may not appreciate the use of names in a vector right now but it can be very useful for extracting certain elements from a vector and other data structures.

### Vector Attributes:

A vector can have three types of attributes: **Names, Dimensions and Classes**. <br>

In terms of classes, R has five basic or *atomic* classes of objects: character, numeric (real numbers), integer, complex, logical (True/False).

We already learned how to assign names to a vector. By assigning names to the vector above we have also assigned attributes to this vector. You can check if a vector has attributes with the function `attributes`.

```{r}
attributes(v3)
```

If the vector has no attributes the result will return as `NULL`.

**1. Arithmetic operations with vectors**

We can perform all the arithmetic operation we listed earlier using vectors instead of single numbers. The arithmetic operations are performed element-by-element on vectors. We can add, subtract, multiply, or divide two or more vectors. For example:

```{r}
a <- c(1, 2, 4, 8, 16)
b <- c(18, 9, 5, 2, 1)

# Addition
a+b

# Subtaction
b-a

# Multiplication
a*b

# Division
b/a
```

<br>

♻️ **Vector Recycling:** In the previous arithmetic operations you may have noticed that both vector **a** and vector **b** have the same length which makes element-wise operations easy. However, what happens if we want to do the same operations with two vectors of different length? In this case, R employs *Vector Recycling*.<br>

Vector recycling is when R starts repeating the elements of the shorter vector -starting from the beginning- until the two vectors equal in length. For example if vector **a** had elements [1, 2, 4] and we wanted to add it to vector **b** above, then R would extend vector **a** by adding elements "1" and "2" so that both vectors had the same length. Vector **a** would now look like this: [1,2,4,1,2]. <br>

### Vectorisation

The arithmetic operations we showed earlier is an example of **Vectorisation**. <br> Vectorisation in R is the process of doing the same operation on a vector of values as on a single value.

```{=html}
<style>
div.gray { background-color:#ebf5ed; border-radius: 5px; padding: 20px;}
</style>
```
::: gray
Although **vectorisation** seems the "obvious" thing to do, it is not the norm! In other languages we typically have to write a much more complicated expression to do something so simple. This gives R an edge over other languages for data analysis. Vectorisation allows us to express repetitive calculations in a simple and intuitive way saving a lot of time.
:::

**Exercise**: Other examples of vectorisation is the use of functions for mathematical processes. For instance the function `log(a)` will return a new vector with the log values of every element in vector a. Try it for yourselves!<br>

Task1: Create and print a new vector with the log values of vector a. Name the new vector "lna"

```{r}
# Create vector "lna"

```

Task2: You will see that the element of the new vector have many decimal places. Use the `round()` function to reduce the number of decimal points to 2. Applying the `round()` function to the whole vector is a vectored operation as well!

```{r}
# Round the elements of vector "lna"
```

**2. Other Vector Operations** We can apply many other functions to (mostly) numeric vectors to derive simple statistics, change the value of all or some elements and so on. Some simple examples are given below:

a)  Adding a scalar to a vector\

```{r}
va <- c(2, 8, 3, 5, 5, 1, 3, 9, 4) 
va
#Add the number "8" to all elements in the vector va
va + 8
```

b)  Changing the value of one or more elements in a vector

```{r}
#Replace the 5th element of vector va with the value "6"
va[5] <-6
va
```

c)  Sorting vectors

```{r}
sort(va, decreasing=TRUE)

```

We can also employ some mathematical functions to perform operations such as calculating the sum of all the elements in the vector as well as the cumulative sum.

```{r}
# Calculate sum of vector va 
sum(va)
 # Calculate cummulative sum 
cumsum(va)
```

**Question:** What is the output of the `sum()` and `cumsum()` functions? Can you explain the difference in how they work?

**Exercise** Use the functions `min()`, `max()` to find the min and max values of vector **va** and the function `prod()` to calculate the product of vector **va**.

**Descriptive Statistics** We can also extract simple statistics from arithmetic vectors, such as, the mean, median, and standard deviation. (More on descriptive statistics on tomorrow's lectures)

a)  Mean and standard deviation

```{r}
mean(va)

sd(va)

median(va)
```

<br>

**Character Vectors**: The elements of character vectors are what are known as "character string" or simply "string". This term refers to a sequence of characters surrounded by `" "`. Consequently, a character vector is an atomic vector which contains an ordered collection of one or more character strings. Let's see an example below:

```{r}
# Create a character vector with the the types of pets belonging to a class of primary students

pet.type <- c("cat", "dog", "rabbit", "fish", "bird")
```

<br>

**Logical Vectors** The elements of logical vectors can only take the values `TRUE` or `FALSE`. As with other kind of vectors the `c()` and `rep()` functions can also be used to construct logical vectors. <br> An example of a logical vector is shown below:

```{r}
#Microchip status for pet.type vector
microchip <- c(TRUE, TRUE, FALSE, FALSE, FALSE)
```

<br> Logical vectors can have many uses. R uses logical vectors to represent the results of comparisons between vectors. For instance we may be interested in the result of questions such as: "is x greater than y?" or "is x less or equal to y?". First let's create two numeric vectors x and y:

```{r}
x <- seq(from=5, to=16, by=2)
x

y <- rep(9:11, each=2, times=1)
y
```

Now assess whether "`x > y`"x is greater than y".

```{r}
x > y
```

### Relational Operators:

To express the question above in R notation we made use of **relational operators**. Relational operators are used to evaluate the relative value of vector elements. There are six relational operators available in R:

-   **Relational operators:**
-   `x < y` "is x less than y?"
-   `x > y` "is x greater than y?"
-   `x <= y` "is x less or equal to y?"
-   `x >= y` "is x greater or equal to y?"
-   `x == y` "is x equal to y?"
-   `x != y` "is x different to y?"

**NOTE:** The symbol `==` is a relational operator and is different to the symbol `=` which is an **assignment operator** and is used to assign a variable name in the same way as the `<-` **assignment operator**.

### Other operators in R

So far we have come across several different types of operators in R: **arithmetic** operators, **relational** operators and **assignment** operators.\
In fact there are two more types of R operators: **logical operators** and **miscellaneous operators** like the `:` operator we have already seen in many cases.

**Logical** operators are very useful especially when combined with relational operators. Below is a list with the different logical operators.

-   **Logical Operators**
-   `&` Element-wise logical **AND** operator
-   `&&` Logical **AND** operator
-   `|` Element-wise logical **OR** operator
-   `||` Logical **OR** operator
-   `!` The logical **NOT** operator

Operators `&` and `|` perform element-wise operation producing results with the length of the longer operand.

Operators `&&` and `||` examines only the first element of the operands resulting into a single length logical vector.

Zero is considered FALSE and non-zero numbers are taken as TRUE.

**Examples**

```{r}
a1<- c(0, 3, 10)
b1 <- c(8, 9, 12)
a1 & b1
a1 | b1
! b1
! a1
```

In the above example all non-zero numbers are treated as `TRUE` while zero is treated as `FALSE`.

If you want to use the logical **AND** or **OR** operator you need make pairwise element comparisons. For example:

```{r}
a1[1] && b1[1]
a1[2] || b1[3]
```

A more intuitive example is when we compare variables. For example:

```{r}
sum(a1) > 4 & length(b1)>=3
```

We want to check if the sum of all the elements in vector a1 is greater than 4 **AND** the length of vector b1 is equal or more than 3. The `&` operator is an **exclusive** operator. It only returns `TRUE` if all values are `TRUE`.

Now an example with the `|` operator:

```{r}
sum(a1)>4 | length(b1)<3
```

In this case we check whether the sum of all elements in vector a1 is greater than 4 **OR** if the length of vector b1 is less than 3. The `|` operator is an **inclusive** operator as it returns `TRUE` if at least one of the values are true.

Finally the `!` operator *flips* the result of a logical test. For instance, type `!TRUE` in the console and see what happens. It should return `FALSE`. Let's use it in combination with a logical operator:

```{r}
!(4>5)
```

Although 4 is certainly not greater then 5, R returns `TRUE`, simply because the `!` *flips* the question so it evaluates the question "4 NOT greater than 5".

Although it might not be easy to appreciate how useful the `!` operator is from these simple examples, it is very useful when it comes to dealing with databases and large datasets, for extracting data of interest and excluding others that are not required. <br><br> ![R-operators](Pictures%20for%20RMarkdown%20Docs/r_operators.png){fig-align="right" width="50%"} <br>

## Subsetting Vectors

### Indexing

Earlier we learned how to create vectors and perform operations and comparisons. However, in many cases we may want to select specific elements from a vector. This is easily done by using the following notation: <br> ![vector-index](Pictures%20for%20RMarkdown%20Docs/indexing.png){fig-align="right" width="70%"}

**Example** Let's try accessing the pet type "rabbit" from the vector pet.type:

```{r}
pet.type[3]
```

<br> We could also exclude a particular element from a vector. The only difference is that we add the "minus" symbol in front of the index position. <br> ![vector-minus](Pictures%20for%20RMarkdown%20Docs/vector_index.png){fig-align="right" width="70%"}

**Example:** Exclude the pet type "rabbit" from the vector pet.type:

```{r}
pet.type[-3]
```

The same principles apply when we want to index more than one elements from a vector. The only difference is that we need to add a vector inside the square brackets with the elements we want to index.<br> ![vector-index-many](Pictures%20for%20RMarkdown%20Docs/vector_index_many.png){fig-align="right" width="70%"}

Similarly to exclude several elements from a vector we add the symbol "minus" in from of the vector with the elements we want to exclude:<br> ![vector-exclude-many](Pictures%20for%20RMarkdown%20Docs/vector_exclude_many.png){fig-align="right" width="70%"}

If we have named vectors, we can index the vector by referencing the name of the element we want to select:<br> ![vector-index-name](Pictures%20for%20RMarkdown%20Docs/vector_index_name.png){fig-align="right" width="70%"}

Let's attribute names to the vector pet.type to indicate their pet name:

```{r}
names(pet.type) <- c("Ginger", "Waffle", "Benjie", "Goldie", "Twitty")
```

Now select the second element from the pet.type by indexing its name:

```{r}
pet.type["Waffle"]
```

Finally, we can index a vector by using logical vectors!

**Example**:

```{r}
vtest <- c("John Doe", "Jane Doe", "Steve Graves", "Adam Smith", "Amy Ward") 
```

Next create a logical vector called lvec:

```{r}
lvec <- c(TRUE, FALSE, TRUE, TRUE, FALSE)
```

Now combine the two previous vectors and see what happens:

```{r}
vtest1 <-vtest[lvec]

# Print the new vector:
vtest1
```

**Slicing Vectors** If we want to select consecutive elements from a vector we can use the following notation: ![vector-slicing](Pictures%20for%20RMarkdown%20Docs/vector_slicing.png){fig-align="right" width="70%"}

Equally, if we want to select all the elements of a vector except a series of consecutive elements (slice) we use the same notation with the "minus" sign at the front:<br> ![vector-slicing-minus](Pictures%20for%20RMarkdown%20Docs/vector_slicing_minus.png){fig-align="right" width="70%"}

**How to "slice" a vector using comparison operators**. <br> For example, first create a numeric vector

```{r}
#create a numeric vector 
v.num <- seq(3,77, by=4)
#print v.num
v.num
```

Next select all the values greater or equal than 50

```{r}
v.num[v.num >=50]
```

To avoid any confusion with which type of brackets to use for indexing vectors and R objects in general we can use the following mnemonic: <br>

![](Pictures%20for%20RMarkdown%20Docs/Function_notation.png){fig-align="center" width="80%"}

![](Pictures%20for%20RMarkdown%20Docs/Indexing_notation.png)

<br>

### Factors

Factors is a special case of vector that is solely used to represent [categorical or ordinal]{style="color:red"} variables.

We can create factors with the function `factor()`. For example:

```{r}
#Create a vector to store the gender of the pets included in the vector pet.type
pet.gender <- factor(c("male", "female", "male", "female", "female"))

#print the results
pet.gender
```

You can also check the class and type of the vector we just created above.

```{r}
class(pet.gender)
typeof(pet.gender)
```

As we can see the type of the vector pet.gender is *integer*. This is because factors are considered numeric type vectors in R!

#### Adding Factor Levels

Earlier we saw that R printed the levels in the vector `pet.gender`. There are cases, when we want to add more levels than the levels already existing within a vector of class factor. For instance let's create a vector with the blood type of a number of patients in a hospital with a specific condition

```{r}
blood.type <- factor(c("O", "AB", "A", "A"), levels = c("A", "B", "AB", "O"))
blood.type
```

This means that although currently the patients in this vector have only three blood types, when we define the levels we need to add all the possible blood types, as we may want to include more patients in the future.

#### Ordering Levels in a Factor

**Ordinal** are categorical variables that can be ordered. For example let's create a vector listing the symptoms of the patients above:

```{r}
symptoms.patients <- factor(c("SEVERE", "MILD", "MODERATE", "SEVERE"),
levels = c("MILD", "MODERATE", "SEVERE"), ordered = TRUE)

#print the factor
symptoms.patients
```

Since symptoms is an ordinal variable we can use relational operations to perform comparisons within the vector elements

```{r}
#Display which elements from vector symptoms.patients have symptoms higher than MODERATE
symptoms.patients > "MODERATE"
```

## Matrices

A matrix is an R object in which the elements are arranged in a two-dimensional rectangular layout. Matrices are natural extensions of vectors and like them they **contain elements of the same atomic types**. Matrices commonly contain numeric elements and they are very useful for mathematical operations.<br>

**NOTE**:Though we can create a matrix containing only characters or only logical values, they are not of much use.

**Creating Matrices**

1.  To create a matrix in R we can use the matrix() function as follows:

```{r}
M <- matrix(c(1, 3, 5, 7, 9, 11), nrow = 2, byrow=TRUE)
#Print matrix M
M
```

**NOTE** In the previous example we specified `byrow=TRUE` which tells R to start filling the matrix *by row*. The default value in the `matrix()` function is `byrow=FALSE`, which means if we leave this argument empty the matrix will be filled *by column*. You can try it for yourselves and see the difference. <br>

2.  We can also convert a vector into a matrix by changing its dimensions. For example:

```{r}
 #create a numeric vector
vec <- seq(2, 25, by=2.5)
vec
```

Next change the dimensions of the vector to be two-dimensional:

```{r}
dim(vec) <- c(2, 5)
vec
```

We can check the dimensions of a matrix with the functions `nrow()`, `ncol()` and `dim()`as follows:

```{r}
#check the number of rows
nrow(M)
#check the number of columns
ncol(M)
#check the dimensions of matrix M (#rows, #columns)
dim(M)
```

Another way to check the number of rows and columns of a matrix is as follows:

```{r}
#check number of rows
dim(M)[1]
#check number of columns
dim(M)[2]
```

3.  Finally we can create a matrix by combining vectors of equal length (and same atomic type).\
    We can bind together vectors by row or by column as in the examples below:

```{r}
#Create three numeric vectors of the same length
x1 <- 1:6
x2 <- 2:7
x3 <- seq(3, 18, by=3)
```

**a)** Bind by row: Use the rbind() function to bind the vectors x1, x2, x3 by row

```{r}
XR <- rbind(x1,x2,x3)
XR
```

**b)** Bind by column: Use the cbind() function to bind the vectors x1, x2, x3 by column

```{r}
XC <- cbind(x1,x2,x3)
XC
```

**Arithmetic Operations with Matrices** We can use numeric matrices to perform arithmetic operations similar to vectors. For example we can multiply a matrix by a scalar which will multiply each element of the matrix by the same number:

```{r}
# Multiply a scalar with a matrix
A <- 2*XR
#Print new matrix A   
A
```

We can add or subtract matrices of the same dimensions:

```{r}
# Matrix addition
B <- A - 3*XR
B
```

We can multiply or divide matrices of the same dimensions:

```{r}
# Matrix Multiplication (element by element)
AB <-A*B
AB
#Matrix Division (element by element)
A_B <-A/B
A_B
```

We can also perform *Algebraic* matrix multiplication in R using the operator `%*%` given the two matrices are conformable. For example, let's see if we can multiply matrix **XC** by Matrix **XR**. First check their dimensions:

```{r}
dim(XC)
dim(XR)
```

The two matrices are conformable as the number of columns of **XC** is the same as the number of rows of **XR**. Now we can go ahead and perform the multiplication:

```{r}
XX <- XC %*% XR
XX
```

```{=html}
<style>
div.orange { background-color:#fff9e6; border-radius: 5px; padding: 20px;}
</style>
```
::: orange
**NOTE:** Algebraic matrix multiplication is **not commutative**! **A·B ≠ B·A**
:::

<br>

**Matrix Descriptive Statistics** Similar to vectors we can also extract simple statistics from matrices using the same functions. For example:

```{r}
#Mean 
mean(XX)
sd(XX)
min(XX)
max(XX)
```

However, knowing the mean, sd and so on for the whole matrix is not very useful. Most of the time we are interested in rows or columns. For example, each row might represent one sample and each column a variable we measured for all the samples. To extract those statistics per column or row we can make use of the `apply()` function which is another example of vectorisation. For example:

```{r}
#calculate the mean for each row of  matrix
apply(XX, 1, mean)

#calculate the mean for each column of  matrix
apply(XX, 2, mean)
```

We can do the same with other functions, eg. `min()`, `max()`, `sd()`, `sum()` and so on. <br> <br> **Sub-setting Matrices** As well as indexing vectors, we can use the square brackets `[]` to index a matrix. The convention for indexing matrices is: [[rows, columns]]{style="color:red"}. <br> Let's see some examples below:

**Extract elements from a matrix** a) Extract element from matrix XX from the 1st row and 2nd column

```{r}
XX[1,2]

```

b)  Extract the 3rd column from matrix XX

```{r}
XX[,3]
```

c)  Extract rows 2:3 and columns 3:4 from matrix XX

```{r}
XX[2:3, 3:4]
```

We can also use matrix indexing to replace the values of specific matrix elements. Example: Replace elements in rows 2:3 and 3:4 in matrix XX with zeros

```{r}
XX[2:3, 3:4] <- 0
```

Now print matrix XX and see if the values have changed.

### Naming columns and vectors in a matrix

Similar to vectors we can also assign names to columns and rows in a matrix which is very useful when we are analysing experimental data. For instance row names could represent sample names and column names could represent variable names. To name matrix rows we can use the `rownames()` function and to name matrix columns we can use the `colnames()` function. <br> **Example:** Let's assume you have measured the weight of 5 apples from two different varieties after harvest and you want to create a matrix to store the results. First create a vector with the weight measurements for each sample:

```{r}
# Create a vector with the apple weights in grams
weight <- c(80.3, 93.1, 88.6, 90.4, 85.1, 67.2, 69.6, 72.5, 63.9, 71.4)
```

Then turn this vector into a matrix with 5 rows and 2 columns using the matrix function:

```{r}
APPLES <- matrix(weight, nrow = 5) 
```

Print the matrix `APPLES` to see how it looks. Each column represents a different cultivar. To make the matrix more informative we can name each column by the cultivar name and each row by the sample number as shown below:

```{r}
# Name the APPLE matrix rows:
rownames(APPLES) <-c("Rep1", "Rep2", "Rep3", "Rep4", "Rep5")

# Name the APPLE matrix columns:
colnames(APPLES) <- c("Bramley", "Gala")
```

Print the matrix APPLES to see if it worked.

**Transposing Matrices:** Sometimes we may find that we want to change the orientation of a matrix, either for algebraic operations or simply to make it easier to work with the data. Let's say in the previous example we wanted to display the cultivar name in each row and the sample number in the columns. We can easily do so with the function `t()`. For example:

```{r}
# Transpose matrix APPLES:
t(APPLES)
```

<br>

## Arrays

As we saw earlier, a matrix is a two-dimensional data structure which contain elements of the same atomic types. There is another type of data structure which can store data in more than two dimensions called **Arrays**. An array is created with the help of the `array()` function. This function takes a vector as an input (argument) and uses the value of the dim parameter to create an array. Suppose we want to create an array of dimension (2,3,4), then we need to provide a vector for the dim argument within the `array()` function in order to create the 3-dimensional array. An example is given below:

```{r}
Array1 <-array(1:20, dim=c(2,3,4))
Array1
```

The result of the above operation is that we created four rectangular matrices of two rows and three columns each.

**NOTE** In this course we will not use multidimensional arrays as they are out of scope. This is for reference only! <br>

## Data Frames

Until now we have only encountered data structures of the same data type, e.g. numeric data. However, in practice data analysis usually involves diverse collections of data ("data sets") which include different types of data types such as numerical, categorical and so on. An experiment typically considers many different "variables". For example if we want to study the effect of **caffeine intake** on the **amount of sleep** of 10 volunteers, we need to take many different variable into account, such as *amount of caffeine consumed*, *age*, *occupation*, *underline health issues*, *sex*, *stress levels*, etc. As you can see some of these variables are numeric while others are categorical. We could work with each of these variables in isolation, but this could easily lead to errors. Instead it would be very useful to gather all the related variables into a single data structure. **Data Frames** address this problem which makes them one of the most useful and popular data structures in R and justify R's reputation as one of the best environments for data analysis.

**Data Frames** are two-dimensional table-like objects with rows and columns. They collect together different variables and store each of them in a different column. In this context, each column is a vector of some kind, such as arithmetic, character etc.

The best way to understand this is to create a data frame. We can use the function `data.frame()` to do this.\
Let's take the previous example of caffeine intake and amount of sleep. Assume we have taken into account the participants' *age, sex, caffeine intake (mg), amount of sleep per night and sleep breaks*. For example:\
a) Create **age** vector

```{r}
age <-c("18-29", "30-49", "30-49", "18-29", "30-49", ">=70", "30-49", "50-69", "18-29", "50-69")
```

b)  Create **sex** vector

```{r}
sex <- factor(c("Male", "Female", "Male", "Male", "Female", "Male", "Female", "Female", "Male", "Male"))
```

c)  Create **caffeine** intake (mg) vector

```{r}
caffeine <- c(0, 200, 400, 0, 200, 200, 50, 400, 0, 400)

```

d)  Create **sleep amount** vector

```{r}
sleep.amount <- factor(c("6-8 h","<=5 h", "6-8 h", "6-8 h", "<=5 h", "<=5 h", ">8 h","<=5 h", "6-8 h", "<=5 h" ), 
                       levels = c("<=5 h", "6-8 h",">8 h"), ordered = TRUE)
```

e)  Create **sleep break** vector

```{r}
sleep.break <- c("NO", "YES", "YES", "NO", "NO", "YES", "YES", "NO", "YES", "YES")
```

Create data frame:

```{r}
Sleep.Data <- data.frame(age, sex, caffeine, sleep.amount, sleep.break)
```

You can print the data frame in the console to inspect it.

**NOTE:** We can also use the `colnames()` and `rownames()` or `row.names()` functions to assign column and row names if we wish to. Alternatively we can assign column names when creating the data frame. For example:

```{r}
Sleep.Data <- data.frame(Age = age, SEX = sex, Caffeine_mg = caffeine, Sleep_Length = sleep.amount, Sleep_Break = sleep.break)
```

### Exploring Data Frames

In the previous example we printed the data frame we created in console to see its contents. However, when working with larger data frames this is not recommended. We can use the `head()` and `tail()` functions instead to extract the first and last rows of a data frame. We can define the number of rows we want to see with the `n` argument inside the functions.\
For example:

```{r}
head(Sleep.Data, n=3)
```

The same for `tail()`

```{r}
tail(Sleep.Data, n=2)
```

Finally, we can visualise the whole data frame in a separate spreadsheet with the function `View()`:

```{r}
View(Sleep.Data)
```

We can also use the `dim()` function to inspect the dimensions of a data frame:

```{r}
dim(Sleep.Data)
```

The first number in the output is the number of rows and the second the number of columns.

**NOTE:** If we are interested in only the number of rows or columns we can use the functions `ncol()` and `nrow()` respectively.

We can also display the column or row names with the functions `colnames()` and `rownames()`. For example:

```{r}
colnames(Sleep.Data)
```

### Extracting Data from Data Frames

There are several ways we can extract data from a data frame. Below are some examples on how to index and extract data from dataframes:\
1) Using the `$` operator:

```{r}
Sleep.Data$Caffeine_mg
```

2)  Using double square brackets `[[]]`

```{r}
Sleep.Data[["Caffeine_mg"]]
```

3)  For more than one variable we can provide a vector with the variable names to extract:

```{r}
Sleep.Data[c("Age", "Sleep_Length")]
```

**NOTE:** If using either single `[]` or double`[[]]` remember to use `""` around the variable name(s).

**Adding variables**: A useful operation we can do with data frames is adding variables (columns) to the data frame. We can do this as follows:

```{r}
Sleep.Data$Stress <-c("Low", "High", "High", "Moderate", "Low", "High", "Moderate", "Low", "High", "Moderate")
```

Check if it worked

```{r}
Sleep.Data
```

### Indexing data frames

Another use for the square brackets `[]` is that they allow us to subset rows and columns at the same time (as we did with matrices).\
For example:

```{r}
Sleep.Data[1:3, 1:2]

```

Or alternatively:

```{r}
Sleep.Data[1:3, c("Age", "SEX")]
```

To subset only rows or columns we can do the following:

```{r}
#Exclude columns 1:2
Sleep.Data[, 3:ncol(Sleep.Data)]
```

```{r}
#Subset rows 3:5
Sleep.Data[3:5, ]
```

## Lists

There is another type of vectors in R called **Lists** which unlike *Atomic Vectors* can contain elements of different data types. Lists are also known as **recursive vectors**.

Some things to remember about Lists are the following: <br>

-   Lists group R objects into a set
-   Lists can store other lists
-   Lists are one-dimensional
-   Lists can store elements of different basic types
-   Lists have no inherent function

**Create Lists:** Lists can be created using the `list()` function, which takes an arbitrary number of arguments. Let's create a list to store the results for a group of patients in a hospital treated for bacterial infection:

```{r}
patient.record <- list(patient.name = c("John Doe", "Jack Smith", "George Williams"), 
                       patient.age = c(54, 36, 48), 
                       patient.medication = c("paracetamol", "penicillin"), 
                       temperature =list(c(38.9, 39.1, 37.8, 37.4, 37.1), c(39.5, 39.7, 38.7, 38.6, 37.9), c(38.8, 39.1, 38.6, 37.7, 37.3)))
```

The list `patient.record` created above contains the names and age of the patients, the medication administered and recordings of their temperature over the last 20 hours. Now lets print this list to inspect it:

```{r}
patient.record
```

### List subsetting

**Extracting elements from a list**

We have several ways to access elements from a list:<br> a) Using double square brackets `[[]]`

```{r}
#Extract the 2nd element from the list patient.record
patient.record[[2]]
```

b)  Using the `$` operator:

```{r}
#Extract the 2nd element from the list patient.record
patient.record$patient.age
```

We can also extract sub-elements from a list as follows

```{r}
#Extract the 1st sub-element from the second element from the list patient.record
patient.record[[2]][1]
```

⚠️**CAUTION** If you use single square brackets `[]` instead of double `[[]]` what will be returned will still be a (smaller) **list** object.

Try it for the 2nd element of list `patient.record`:

```{r}
patient.record[2]
```

The above will return another **list** with only one element (`patient.age`).\
The same is true if we write the following:

```{r}
# Index elements 2:3 from the list patient.record
patient.record[2:3]
```

### Nested lists

To **index** an element from a list nested withing another list we write:

```{r}
# Index the 3rd element from list temperature within the list patient.record
patient.record[[4]][3]
```

The above operation will still return a **list** with one element.

To **extract** a sub-element from a list nested within another list we write:

```{r}
# Extract the 3rd element from list temperature within the list patient.record
patient.record[[4]][[3]]
```

This will return a **vector** with the temperature recordings for the 3rd patient!

In summary: <br>

![](Pictures%20for%20RMarkdown%20Docs/Lists.png)
